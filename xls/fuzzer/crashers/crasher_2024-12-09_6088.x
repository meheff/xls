// Copyright 2024 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// BEGIN_CONFIG
// # proto-message: xls.fuzzer.CrasherConfigurationProto
// exception: "/xls/tools/simulate_module_main returned a non-zero exit status (1): Error: FAILED_PRECONDITION: Channel \'sample__x12\' is not an input channel"
// issue: "Channel metadata was not being generated by Codegen NG"
// sample_options {
//   input_is_dslx: true
//   sample_type: SAMPLE_TYPE_PROC
//   ir_converter_args: "--top=main"
//   convert_to_ir: true
//   optimize_ir: true
//   use_jit: true
//   codegen: true
//   codegen_args: "--nouse_system_verilog"
//   codegen_args: "--output_block_ir_path=sample.block.ir"
//   codegen_args: "--generator=combinational"
//   codegen_args: "--reset_data_path=false"
//   simulate: true
//   use_system_verilog: false
//   timeout_seconds: 1500
//   calls_per_sample: 0
//   proc_ticks: 128
//   known_failure {
//     tool: ".*codegen_main"
//     stderr_regex: ".*Impossible to schedule proc .* as specified; cannot achieve the specified pipeline length.*"
//   }
//   known_failure {
//     tool: ".*codegen_main"
//     stderr_regex: ".*Impossible to schedule proc .* as specified; cannot achieve full throughput.*"
//   }
//   with_valid_holdoff: false
//   codegen_ng: true
// }
// inputs {
//   channel_inputs {
//     inputs {
//       channel_name: "sample__x12"
//       values: "[(bits[23]:0x7f_ffff, bits[11]:0x2aa), (bits[23]:0x38_ab5b, bits[11]:0x7ff), (bits[23]:0x0, bits[11]:0x3ff), (bits[23]:0x0, bits[11]:0x493), (bits[23]:0x400, bits[11]:0x3ff), (bits[23]:0x3f_ffff, bits[11]:0x206), (bits[23]:0x3f_ffff, bits[11]:0x3ff), (bits[23]:0x3f_ffff, bits[11]:0x555), (bits[23]:0x3f_ffff, bits[11]:0x598)]"
//       values: "[(bits[23]:0x7f_ffff, bits[11]:0x555), (bits[23]:0x2a_aaaa, bits[11]:0x7ff), (bits[23]:0x5f_ba4c, bits[11]:0x3ff), (bits[23]:0x55_5555, bits[11]:0x555), (bits[23]:0x4000, bits[11]:0x555), (bits[23]:0x7f_ffff, bits[11]:0x555), (bits[23]:0x46_b26d, bits[11]:0x0), (bits[23]:0x7f_ffff, bits[11]:0x3ff), (bits[23]:0x800, bits[11]:0x3f8)]"
//       values: "[(bits[23]:0x0, bits[11]:0x0), (bits[23]:0x0, bits[11]:0x2aa), (bits[23]:0x1b_a067, bits[11]:0x555), (bits[23]:0x40, bits[11]:0x8), (bits[23]:0x0, bits[11]:0x3ff), (bits[23]:0x55_5555, bits[11]:0x3ff), (bits[23]:0x2a_aaaa, bits[11]:0x2aa), (bits[23]:0x0, bits[11]:0x555), (bits[23]:0x55_5555, bits[11]:0x100)]"
//       values: "[(bits[23]:0xf01b, bits[11]:0x0), (bits[23]:0x7f_ffff, bits[11]:0x3ff), (bits[23]:0x3f_ffff, bits[11]:0x3ff), (bits[23]:0x7f_ffff, bits[11]:0x2a0), (bits[23]:0x7f_ffff, bits[11]:0x3ff), (bits[23]:0x2_f509, bits[11]:0x7ff), (bits[23]:0x3f_ffff, bits[11]:0x555), (bits[23]:0x3f_ffff, bits[11]:0x80), (bits[23]:0x2a_aaaa, bits[11]:0x3ff)]"
//       values: "[(bits[23]:0x20_0000, bits[11]:0x2aa), (bits[23]:0x3f_ffff, bits[11]:0x0), (bits[23]:0x1000, bits[11]:0x555), (bits[23]:0x0, bits[11]:0x2aa), (bits[23]:0x69_55cc, bits[11]:0x0), (bits[23]:0x8000, bits[11]:0x2aa), (bits[23]:0x2_0000, bits[11]:0x618), (bits[23]:0x7f_ffff, bits[11]:0x4), (bits[23]:0x36_7353, bits[11]:0x555)]"
//       values: "[(bits[23]:0x55_5555, bits[11]:0x0), (bits[23]:0xd_4920, bits[11]:0x555), (bits[23]:0x7f_ffff, bits[11]:0x555), (bits[23]:0x2a_aaaa, bits[11]:0x2aa), (bits[23]:0x2a_aaaa, bits[11]:0x7ef), (bits[23]:0x55_5555, bits[11]:0x200), (bits[23]:0x3f_ffff, bits[11]:0x6a7), (bits[23]:0x0, bits[11]:0x3ff), (bits[23]:0x2a_aaaa, bits[11]:0x555)]"
//       values: "[(bits[23]:0x36_02d0, bits[11]:0x555), (bits[23]:0x55_5555, bits[11]:0x555), (bits[23]:0x200, bits[11]:0x7ff), (bits[23]:0x7f_ffff, bits[11]:0x3ff), (bits[23]:0x55_5555, bits[11]:0x2aa), (bits[23]:0x3f_ffff, bits[11]:0x3ff), (bits[23]:0x4000, bits[11]:0x25d), (bits[23]:0x3f_ffff, bits[11]:0x2), (bits[23]:0x55_5555, bits[11]:0x0)]"
//       values: "[(bits[23]:0x20_0000, bits[11]:0x3ff), (bits[23]:0x0, bits[11]:0x7ff), (bits[23]:0x3f_ffff, bits[11]:0x6db), (bits[23]:0x20, bits[11]:0x7ff), (bits[23]:0x7f_ffff, bits[11]:0xd0), (bits[23]:0x3f_ffff, bits[11]:0x0), (bits[23]:0x0, bits[11]:0x4), (bits[23]:0x8_0000, bits[11]:0x555), (bits[23]:0x55_5555, bits[11]:0x0)]"
//       values: "[(bits[23]:0x3f_ffff, bits[11]:0x3ff), (bits[23]:0x7f_ffff, bits[11]:0x7ff), (bits[23]:0x3f_ffff, bits[11]:0x0), (bits[23]:0x8000, bits[11]:0x100), (bits[23]:0x2a_aaaa, bits[11]:0x7ff), (bits[23]:0x0, bits[11]:0x10), (bits[23]:0x2a_aaaa, bits[11]:0x244), (bits[23]:0x32_3652, bits[11]:0x3ff), (bits[23]:0x55_5555, bits[11]:0x0)]"
//       values: "[(bits[23]:0x2a_aaaa, bits[11]:0x3ff), (bits[23]:0x40_0000, bits[11]:0x0), (bits[23]:0x0, bits[11]:0x7ff), (bits[23]:0x36_cd55, bits[11]:0x3ff), (bits[23]:0x10_0000, bits[11]:0x2aa), (bits[23]:0x5e_17ed, bits[11]:0x4), (bits[23]:0x55_5555, bits[11]:0x3ff), (bits[23]:0x2b_1bb6, bits[11]:0x7ff), (bits[23]:0x51_59dc, bits[11]:0x7ff)]"
//     }
//   }
// }
// 
// END_CONFIG
const W32_V9 = u32:0x9;
type x11 = (u23, u11);
proc main {
    x12: chan<x11[W32_V9]> in;
    config(x12: chan<x11[W32_V9]> in) {
        (x12,)
    }
    init {
        ()
    }
    next(x0: ()) {
        {
            let x1: () = for (i, x) in u4:0x0..u4:0b1 {
                x
            }(x0);
            let x2: u1 = match x0 {
                () => bool:0x1,
                _ => bool:0x1,
            };
            let x3: token = join();
            let x4: u1 = bit_slice_update(x2, x2, x2);
            let x5: u1 = -x2;
            let x6: u1 = -x5;
            let x7: u7 = x2 ++ x4 ++ x4 ++ x4 ++ x2 ++ x2 ++ x4;
            let x8: u4 = x4 ++ x6 ++ x4 ++ x5;
            let x9: bool = rev(x4);
            let x10: u7 = x7 & x7;
            let x13: (token, x11[W32_V9]) = recv(join(), x12);
            let x14: token = x13.0;
            let x15: x11[W32_V9] = x13.1;
            let x16: bool = x10[3+:bool];
            let x17: bool = x1 == x0;
            let x18: bool = or_reduce(x8);
            let x19: bool = decode<bool>(x4);
            x0
        }
    }
}
